# 3Ô∏è‚É£ Capa de Aplicaci√≥n (puertos, commands, responses, services)

---

En esta capa es donde ver√°s la `arquitectura hexagonal en su m√°xima expresi√≥n`, porque aqu√≠ es donde los
puertos conectan todo sin que nada sepa nada de infraestructura.

### üëâ Rol de la capa de aplicaci√≥n

- Coordina el flujo de los casos de uso.
- Orquesta entidades de dominio, repositorios y servicios externos.
- Define contratos claros (commands y responses) entre el mundo externo y el dominio.
- No contiene l√≥gica de negocio detallada, esa vive en el dominio.
- Se asegura de que las reglas del negocio se ejecuten en el orden correcto.

### üëâ Orden natural de construcci√≥n:

````
Commands ‚Üí Responses ‚Üí Puertos de Entrada (Use Cases) ‚Üí Puerto de Salida ‚Üí Service
````

### üëâ Enfoque `Vertical Slicing`

Trabajaremos feature por feature, manteniendo consistencia:

````
customer ‚Üí account ‚Üí transaction
````

---

# üë§ Customer

## Customer ‚Äì DTOs

### ‚úÖ Buenas pr√°cticas reflejadas

- `Separaci√≥n clara` ‚Üí `Commands` y `Responses` son contratos entre `aplicaci√≥n` e `infraestructura`.
- `Inmutabilidad` ‚Üí al usar `record`, los DTOs son inmutables y expresivos.
- `Lenguaje del negocio` ‚Üí los nombres comunican intenci√≥n (`CreateCustomerCommand`, `CustomerResponse`).
- `Protecci√≥n del dominio` ‚Üí nunca se expone directamente la entidad de dominio `Customer`.

### Command

`Commands` ‚Üí son objetos de entrada que encapsulan los datos necesarios para ejecutar un caso de uso.

- Ejemplo: `CreateCustomerCommand` representa la intenci√≥n de registrar un nuevo cliente.
- Ejemplo: `UpdateCustomerCommand` representa la intenci√≥n de actualizar datos de un cliente existente.

````java
public record CreateCustomerCommand(String documentNumber,
                                    DocumentType documentType,
                                    String firstName,
                                    String lastName,
                                    String email,
                                    String phone) {
}
````

````java
public record UpdateCustomerCommand(String firstName,
                                    String lastName,
                                    String phone) {
}
````

### Response

`Responses` ‚Üí son objetos de salida que encapsulan los datos que el caso de uso devuelve al adaptador de entrada
(ej. controlador REST).

- Nunca se expone la entidad de dominio directamente, se traduce a un DTO de respuesta.
- Ejemplo: `CustomerResponse` devuelve informaci√≥n del cliente en un formato seguro y estable para la API.

````java
public record CustomerResponse(String customerCode,
                               String documentNumber,
                               DocumentType documentType,
                               String firstName,
                               String lastName,
                               String fullName,
                               String email,
                               String phone,
                               CustomerStatus status,
                               LocalDateTime createdAt,
                               LocalDateTime updatedAt) {
}
````

## üìë Customer ‚Äì Puertos de Entrada (Use Cases)

Los `puertos de entrada` son `interfaces` que definen `QU√â puede hacer el sistema` desde el exterior. Cada caso de uso
es una interfaz separada (`Interface Segregation Principle`). El controlador REST los inyecta y los invoca sin saber
nada de la implementaci√≥n concreta.

Cada caso de uso es una interfaz separada con un √∫nico m√©todo `execute()`. Esto aplica el principio de segregaci√≥n de
interfaces: el controlador solo inyecta los casos de uso que necesita, no un servicio gigante con todo.

````java
public interface CreateCustomerUseCase {
    CustomerResponse execute(CreateCustomerCommand command);
}
````

````java
public interface GetCustomerByIdUseCase {
    CustomerResponse execute(String customerCode);
}
````

````java
public interface GetAllCustomersUseCase {
    List<CustomerResponse> execute();
}
````

````java
public interface UpdateCustomerUseCase {
    CustomerResponse execute(String customerCode, UpdateCustomerCommand command);
}
````

````java
public interface DeleteCustomerUseCase {
    void executeDelete(String customerCode);
}
````

## üìë Customer ‚Äì Puertos de Salida

El `puerto de salida` define `QU√â necesita la aplicaci√≥n del exterior` (en este caso, de la persistencia) sin saber
C√ìMO se implementa. `La implementaci√≥n concreta (JPA) vive en infraestructura`.

> `Nota`: esta interfaz (`CustomerRepositoryPort`) vive en la capa de aplicaci√≥n, pero es implementada por la capa de
> infraestructura. Eso es exactamente la `Inversi√≥n de Dependencias (DIP)` en acci√≥n.

`CustomerRepositoryPort` define exactamente lo que la aplicaci√≥n necesita de la persistencia, nada m√°s.
No expone m√©todos de JPA ni nada tecnol√≥gico.

````java
public interface CustomerRepositoryPort {

    // Persiste un cliente nuevo o actualiza uno existente
    Customer save(Customer customer);

    // Busca un cliente por su referencia externa (la que viaja en la API)
    Optional<Customer> findByCustomerCode(String customerCode);

    // Verifica si ya existe un cliente con ese n√∫mero de documento
    boolean existsByDocumentNumber(String documentNumber);

    // Verifica si ya existe un cliente con ese email
    boolean existsByEmail(String email);

    // Retorna todos los clientes registrados
    List<Customer> findAll();
}
````

### üéØ Buenas pr√°cticas reflejadas

- `Lenguaje del negocio` ‚Üí m√©todos como `findByCustomerCode` o `existsByDocumentNumber` comunican intenci√≥n clara.
- `No exponer tecnolog√≠a` ‚Üí no hay m√©todos de JPA (`findAllBy`, `deleteById`, etc.), solo contratos de negocio.
- `Testabilidad` ‚Üí al ser una interfaz, se puede mockear f√°cilmente en pruebas de aplicaci√≥n.
- `Flexibilidad` ‚Üí permite m√∫ltiples implementaciones (ej. JPA, memoria, API externa) sin afectar la capa de aplicaci√≥n.

## Customer ‚Äì CustomerService

- Implementa todos los casos de uso de la feature en una sola clase. En proyectos m√°s grandes podr√≠as separarlo,
  pero para nuestro contexto es limpio y manejable.
- `generateCustomerCode()` vive aqu√≠ porque generar el c√≥digo es responsabilidad de la aplicaci√≥n, no del dominio
  ni de la infraestructura.
- `@Transactional(readOnly = true)` en los m√©todos de consulta ‚Äî optimizaci√≥n real que Hibernate usa para no rastrear
  cambios en las entidades.
- El mapper `toResponse()` es privado y manual, sin `MapStruct`, porque transforma `dominio ‚Üí respuesta de aplicaci√≥n`,
  no involucra infraestructura.
- `@RequiredArgsConstructor` de `Lombok` genera el constructor para inyecci√≥n por constructor, que es la forma
  recomendada en Spring.

### Sobre `@Service` y `@Transactional` en la capa de Aplicaci√≥n:

Ambas anotaciones pertenecen a `Spring Framework`, lo que introduce un acoplamiento t√©cnico en una capa que idealmente
deber√≠a ser independiente. Sin embargo, en proyectos bancarios y empresariales reales con Spring Boot como framework
base, este acoplamiento se acepta como un `trade-off` consciente y justificado por las siguientes razones:

- `@Service` es simplemente un marcador sem√°ntico que permite a Spring registrar la clase como un bean gestionado.
  Si se migrara a otro framework, el cambio se limita a reemplazar esta anotaci√≥n, no a reescribir l√≥gica.
- `@Transactional` gestiona la atomicidad de las operaciones, una responsabilidad que pertenece naturalmente a la capa
  de aplicaci√≥n, ya que es quien sabe qu√© operaciones deben ser at√≥micas.
- El costo de este acoplamiento es m√≠nimo y localizado: afecta solo los imports, no la l√≥gica de negocio.
- El beneficio es m√°ximo: simplicidad, menos c√≥digo y aprovechamiento de capacidades probadas del framework.

> **¬øQu√© es un `trade-off`?**
>
> Un `trade-off` es una decisi√≥n de ingenier√≠a en la que se acepta conscientemente una desventaja o costo a cambio de
> obtener un beneficio mayor. En otras palabras, es una `concesi√≥n razonada`: sabes que est√°s sacrificando algo, pero
> decides hacerlo porque lo que ganas vale m√°s que lo que pierdes.
>
> **Ejemplo cotidiano:** elegir un auto grande sacrificas el ahorro de combustible, pero ganas comodidad y espacio.
> Sabes el costo, lo aceptas porque el beneficio lo justifica.
> En ingenier√≠a de software los `trade-offs` son inevitables y tomar buenas decisiones no significa encontrar la
> soluci√≥n perfecta, sino `elegir conscientemente qu√© desventajas est√°s dispuesto a aceptar` en funci√≥n del contexto,
> el equipo y los objetivos del proyecto.

En la pr√°ctica, cambiar Spring Boot por otro framework es un evento extremadamente raro. Optimizar para ese escenario
hipot√©tico a costa de complejidad innecesaria hoy no es una decisi√≥n de ingenier√≠a racional.

