# 3Ô∏è‚É£ Capa de Aplicaci√≥n (puertos, commands, responses, services)

---

En esta capa es donde ver√°s la `arquitectura hexagonal en su m√°xima expresi√≥n`, porque aqu√≠ es donde los
puertos conectan todo sin que nada sepa nada de infraestructura.

### üëâ Rol de la capa de aplicaci√≥n

- Coordina el flujo de los casos de uso.
- Orquesta entidades de dominio, repositorios y servicios externos.
- Define contratos claros (commands y responses) entre el mundo externo y el dominio.
- No contiene l√≥gica de negocio detallada, esa vive en el dominio.
- Se asegura de que las reglas del negocio se ejecuten en el orden correcto.

### üëâ Orden natural de construcci√≥n:

````
Commands ‚Üí Responses ‚Üí Puertos de Entrada (Use Cases) ‚Üí Puerto de Salida ‚Üí Service
````

### üëâ Enfoque `Vertical Slicing`

Trabajaremos feature por feature, manteniendo consistencia:

````
customer ‚Üí account ‚Üí transaction
````

---

# üë§ Customer

## Customer ‚Äì DTOs

### ‚úÖ Buenas pr√°cticas reflejadas

- `Separaci√≥n clara` ‚Üí `Commands` y `Responses` son contratos entre `aplicaci√≥n` e `infraestructura`.
- `Inmutabilidad` ‚Üí al usar `record`, los DTOs son inmutables y expresivos.
- `Lenguaje del negocio` ‚Üí los nombres comunican intenci√≥n (`CreateCustomerCommand`, `CustomerResponse`).
- `Protecci√≥n del dominio` ‚Üí nunca se expone directamente la entidad de dominio `Customer`.

### Command

`Commands` ‚Üí son objetos de entrada que encapsulan los datos necesarios para ejecutar un caso de uso.

- Ejemplo: `CreateCustomerCommand` representa la intenci√≥n de registrar un nuevo cliente.
- Ejemplo: `UpdateCustomerCommand` representa la intenci√≥n de actualizar datos de un cliente existente.

````java
public record CreateCustomerCommand(String documentNumber,
                                    DocumentType documentType,
                                    String firstName,
                                    String lastName,
                                    String email,
                                    String phone) {
}
````

````java
public record UpdateCustomerCommand(String firstName,
                                    String lastName,
                                    String phone) {
}
````

### Response

`Responses` ‚Üí son objetos de salida que encapsulan los datos que el caso de uso devuelve al adaptador de entrada
(ej. controlador REST).

- Nunca se expone la entidad de dominio directamente, se traduce a un DTO de respuesta.
- Ejemplo: `CustomerResponse` devuelve informaci√≥n del cliente en un formato seguro y estable para la API.

````java
public record CustomerResponse(String customerCode,
                               String documentNumber,
                               DocumentType documentType,
                               String firstName,
                               String lastName,
                               String fullName,
                               String email,
                               String phone,
                               CustomerStatus status,
                               LocalDateTime createdAt,
                               LocalDateTime updatedAt) {
}
````

## üìë Customer ‚Äì Puertos de Entrada (Use Cases)

Los `puertos de entrada` son `interfaces` que definen `QU√â puede hacer el sistema` desde el exterior. Cada caso de uso
es una interfaz separada (`Interface Segregation Principle`). El controlador REST los inyecta y los invoca sin saber
nada de la implementaci√≥n concreta.

Cada caso de uso es una interfaz separada con un √∫nico m√©todo `execute()`. Esto aplica el principio de segregaci√≥n de
interfaces: el controlador solo inyecta los casos de uso que necesita, no un servicio gigante con todo.

````java
public interface CreateCustomerUseCase {
    CustomerResponse execute(CreateCustomerCommand command);
}
````

````java
public interface GetCustomerByIdUseCase {
    CustomerResponse execute(String customerCode);
}
````

````java
public interface GetAllCustomersUseCase {
    List<CustomerResponse> execute();
}
````

````java
public interface UpdateCustomerUseCase {
    CustomerResponse execute(String customerCode, UpdateCustomerCommand command);
}
````

````java
public interface DeleteCustomerUseCase {
    void execute(String customerCode);
}
````

## üìë Customer ‚Äì Puertos de Salida

El `puerto de salida` define `QU√â necesita la aplicaci√≥n del exterior` (en este caso, de la persistencia) sin saber
C√ìMO se implementa. `La implementaci√≥n concreta (JPA) vive en infraestructura`.

> `Nota`: esta interfaz (`CustomerRepositoryPort`) vive en la capa de aplicaci√≥n, pero es implementada por la capa de
> infraestructura. Eso es exactamente la `Inversi√≥n de Dependencias (DIP)` en acci√≥n.

`CustomerRepositoryPort` define exactamente lo que la aplicaci√≥n necesita de la persistencia, nada m√°s.
No expone m√©todos de JPA ni nada tecnol√≥gico.

````java
public interface CustomerRepositoryPort {

    // Persiste un cliente nuevo o actualiza uno existente
    Customer save(Customer customer);

    // Busca un cliente por su referencia externa (la que viaja en la API)
    Optional<Customer> findByCustomerCode(String customerCode);

    // Verifica si ya existe un cliente con ese n√∫mero de documento
    boolean existsByDocumentNumber(String documentNumber);

    // Verifica si ya existe un cliente con ese email
    boolean existsByEmail(String email);

    // Retorna todos los clientes registrados
    List<Customer> findAll();
}
````

### üéØ Buenas pr√°cticas reflejadas

- `Lenguaje del negocio` ‚Üí m√©todos como `findByCustomerCode` o `existsByDocumentNumber` comunican intenci√≥n clara.
- `No exponer tecnolog√≠a` ‚Üí no hay m√©todos de JPA (`findAllBy`, `deleteById`, etc.), solo contratos de negocio.
- `Testabilidad` ‚Üí al ser una interfaz, se puede mockear f√°cilmente en pruebas de aplicaci√≥n.
- `Flexibilidad` ‚Üí permite m√∫ltiples implementaciones (ej. JPA, memoria, API externa) sin afectar la capa de aplicaci√≥n.
