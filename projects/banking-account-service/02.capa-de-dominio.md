# 2ï¸âƒ£ Capa de Dominio (entidades, VOs, enums, excepciones)

---

En esta capa vive el `corazÃ³n del negocio`.

ğŸ“Œ Principios fundamentales:

- `Cero dependencias externas` â†’ no usamos librerÃ­as de terceros.
- `Cero Spring`, `cero JPA` â†’ solo `Java puro`.
- `Expresividad del dominio` â†’ aquÃ­ definimos el vocabulario y las reglas del negocio.

ğŸ‘‰ Orden natural de construcciÃ³n:

````
enums â†’ Value Objects (VOs) â†’ Excepciones â†’ Entidades de Dominio 
````

ğŸ‘‰ Seguiremos el enfoque de `Vertical Slicing` (feature por feature):

````
customer â†’ account â†’ transaction
````

---

## ğŸ‘¤ Customer

### ğŸ“‘ Enums

Los `enums` son simples y directos, sin dependencias. Representan el `vocabulario del negocio`, es decir,
los valores permitidos en nuestro dominio.

````java
public enum CustomerStatus {
    ACTIVE,
    INACTIVE,
    BLOCKED
}
````

````java
public enum DocumentType {
    DNI,
    RUC,
    PASSPORT
}
````

#### ğŸ“˜ Conceptos clave sobre Enums en el Dominio

- `Definen estados o categorÃ­as` â†’ Ejemplo: un cliente puede estar `ACTIVE`, `INACTIVE` o `BLOCKED`.
- `Son inmutables` â†’ una vez definidos, no cambian durante la ejecuciÃ³n.
- `Evitan valores mÃ¡gicos` â†’ en lugar de usar strings dispersos ("ACTIVE", "INACTIVE"), usamos enums que dan seguridad y
  claridad.
- `Reflejan reglas del negocio` â†’ el `DocumentType` enum asegura que solo existan los tipos de documento vÃ¡lidos (`DNI`,
  `RUC`, `PASSPORT`).

### ğŸ¯ Value Objects

Los `Value Objects (VOs)` son objetos `inmutables` definidos por su `valor`, no por su identidad.

ğŸ“Œ Principales caracterÃ­sticas:

- `Representa un concepto del dominio` (ejemplo: un nÃºmero de documento, un email, una moneda, un monto).
- `No tienen identidad propia` â†’ lo que importa es su valor, no â€œquiÃ©nâ€ es.
- `Inmutables` â†’ una vez creados, no se modifican; si cambian, se crea uno nuevo.
- `ComparaciÃ³n por valor` â†’ dos VOs son iguales si sus atributos son iguales.
- `Encapsula reglas de negocio` â†’ puede validar su propio estado (ejm.: un Email VO valida que el formato sea correcto).
- `Principio â€œmake illegal states unrepresentableâ€` â†’ es imposible crear un VO invÃ¡lido, porque su constructor lo
  rechaza.

ğŸ‘‰ Ejemplo:

- Una entidad `Customer` tiene identidad (su `id`).
- Su `Email` es un `Value Object`, porque lo que importa es el valor del correo, no un identificador Ãºnico.

ğŸ‘‰ En Java, los `Records` son ideales para representar `VOs`, ya que son inmutables por naturaleza y expresivos.

#### ğŸ†” `CustomerId(...)`

Representa el `identificador interno` del cliente (`BIGSERIAL` en la BD). Encapsularlo en un VO evita la
`Primitive Obsession` (confundir un `Long` de cliente con un `Long` de cuenta u otro concepto).

````java
public record CustomerId(Long value) {
    public CustomerId {
        if (Objects.isNull(value) || value <= 0) {
            throw new IllegalArgumentException("El ID del cliente debe ser un nÃºmero positivo");
        }
    }
}
````

#### ğŸ”– `CustomerCode(...)`

Representa la `referencia externa` del cliente que viaja en la API.
Formato esperado: `CUS-YYYY-XXXXXX` (ejemplo: `CUS-2025-000001`).

````java
public record CustomerCode(String value) {
    public CustomerCode {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El cÃ³digo de cliente no puede ser vacÃ­o");
        }
        if (!value.matches("^CUS-\\d{4}-\\d{6}$")) {
            throw new IllegalArgumentException("Formato de cÃ³digo de cliente invÃ¡lido. Esperado: CUS-YYYY-XXXXXX");
        }
    }
}
````

#### ğŸ“„ `DocumentNumber(...)`

Representa el `nÃºmero de documento de identidad` del cliente. La validaciÃ³n cubre:

- `DNI` â†’ 8 dÃ­gitos.
- `RUC` â†’ 11 dÃ­gitos.
- `Pasaporte` â†’ hasta 20 caracteres alfanumÃ©ricos.

````java
public record DocumentNumber(String value) {
    public DocumentNumber {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El nÃºmero de documento no puede ser vacÃ­o");
        }
        if (value.length() < 8 || value.length() > 20) {
            throw new IllegalArgumentException("El nÃºmero de documento debe tener entre 8 y 20 caracteres");
        }
    }
}
````

#### ğŸ“§ `Email(...)`

Representa el `correo electrÃ³nico` del cliente, con validaciÃ³n de formato.

````java
public record Email(String value) {

    private static final String EMAIL_REGEX = "^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$";

    public Email {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El email no puede ser vacÃ­o");
        }
        if (!value.matches(EMAIL_REGEX)) {
            throw new IllegalArgumentException("El formato de email es invÃ¡lido: " + value);
        }
    }
}
````

#### ğŸ“˜ Conceptos clave sobre Value Objects

- `Expresividad del dominio` â†’ un `CustomerId` o `Email` comunican mejor la intenciÃ³n que un simple Long o String.
- `Validaciones centralizadas` â†’ cada VO asegura que su estado sea vÃ¡lido desde el inicio.
- `Inmutabilidad` â†’ evita efectos colaterales y asegura consistencia.
- `ReutilizaciÃ³n` â†’ pueden usarse en distintas entidades sin duplicar lÃ³gica.
- `Primitive Obsession` â†’ se evita el uso indiscriminado de tipos primitivos (`String`, `Long`) para conceptos del
  negocio.

### ğŸ¯ Excepciones de dominio

Las `excepciones de dominio` representan violaciones a las reglas de negocio.

ğŸ“Œ Principios clave:

- Son `RuntimeException` â†’ no obligan a capturarlas en cada llamada.
- Se lanzan cuando ocurre una condiciÃ³n invÃ¡lida en el `dominio` (ejemplo: cliente bloqueado, duplicado, inexistente).
- El `GlobalExceptionHandler` en la capa de `infraestructura` se encargarÃ¡ de capturarlas y convertirlas en respuestas
  HTTP apropiadas.
- Refuerzan el principio de `ubicar las reglas de negocio en el dominio`, no en la infraestructura.

````java
public class CustomerNotFoundException extends RuntimeException {
    public CustomerNotFoundException(String customerCode) {
        super("No se encontrÃ³ el cliente con cÃ³digo: %s".formatted(customerCode));
    }
}
````

````java
public class CustomerAlreadyExistsException extends RuntimeException {
    public CustomerAlreadyExistsException(String field, String value) {
        super("Ya existe un cliente registrado con %s: %s".formatted(field, value));
    }
}
````

````java
public class CustomerBlockedException extends RuntimeException {
    public CustomerBlockedException(String customerCode) {
        super("El cliente con cÃ³digo %s se encuentra bloqueado y no puede realizar operaciones".formatted(customerCode));
    }
}
````

````java
public class CustomerInactiveException extends RuntimeException {
    public CustomerInactiveException(String customerCode) {
        super("El cliente con cÃ³digo %s se encuentra inactivo y no puede realizar operaciones".formatted(customerCode));
    }
}
````

#### ğŸ“˜ Conceptos clave sobre excepciones de dominio

- `Expresividad del negocio` â†’ cada excepciÃ³n comunica claramente la regla violada.
- `SeparaciÃ³n de responsabilidades` â†’ Las excepciones de dominio se `definen en el dominio` como parte del vocabulario
  de reglas de negocio. La `capa de aplicaciÃ³n` es la que las lanza durante la ejecuciÃ³n de casos de uso. Finalmente,
  la `infraestructura` las captura y traduce en respuestas tÃ©cnicas (ej. HTTP 404, 409, 403).
- `Evitan estados invÃ¡lidos` â†’ garantizan que el flujo de negocio no continÃºe si las condiciones no se cumplen.
- `Consistencia` â†’ centralizan las reglas de validaciÃ³n y evitan duplicaciÃ³n de lÃ³gica en distintas capas.
- `Mejor comunicaciÃ³n con la API` â†’ al capturarlas en el `GlobalExceptionHandler`, se transforman en mensajes claros
  para el cliente de la API.
