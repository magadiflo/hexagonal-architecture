# 2Ô∏è‚É£ Capa de Dominio (entidades, VOs, enums, excepciones)

---

En esta capa vive el `coraz√≥n del negocio`.

üìå Principios fundamentales:

- `Cero dependencias externas` ‚Üí no usamos librer√≠as de terceros.
- `Cero Spring`, `cero JPA` ‚Üí solo `Java puro`.
- `Expresividad del dominio` ‚Üí aqu√≠ definimos el vocabulario y las reglas del negocio.

üëâ Orden natural de construcci√≥n:

````
enums ‚Üí Value Objects (VOs) ‚Üí Excepciones ‚Üí Entidades de Dominio 
````

üëâ Seguiremos el enfoque de `Vertical Slicing` (feature por feature):

````
customer ‚Üí account ‚Üí transaction
````

---

# üë§ Customer

## üìë Customer ‚Äì Enums

Los `enums` son simples y directos, sin dependencias. Representan el `vocabulario del negocio`, es decir,
los valores permitidos en nuestro dominio.

````java
public enum CustomerStatus {
    ACTIVE,
    INACTIVE,
    BLOCKED
}
````

````java
public enum DocumentType {
    DNI,
    RUC,
    PASSPORT
}
````

### üìò Conceptos clave sobre Enums en el Dominio

- `Definen estados o categor√≠as` ‚Üí Ejemplo: un cliente puede estar `ACTIVE`, `INACTIVE` o `BLOCKED`.
- `Son inmutables` ‚Üí una vez definidos, no cambian durante la ejecuci√≥n.
- `Evitan valores m√°gicos` ‚Üí en lugar de usar strings dispersos ("ACTIVE", "INACTIVE"), usamos enums que dan seguridad y
  claridad.
- `Reflejan reglas del negocio` ‚Üí el `DocumentType` enum asegura que solo existan los tipos de documento v√°lidos (`DNI`,
  `RUC`, `PASSPORT`).

## üéØ Customer ‚Äì Value Objects

Los `Value Objects (VOs)` son objetos `inmutables` definidos por su `valor`, no por su identidad.

üìå Principales caracter√≠sticas:

- `Representa un concepto del dominio` (ejemplo: un n√∫mero de documento, un email, una moneda, un monto).
- `No tienen identidad propia` ‚Üí lo que importa es su valor, no ‚Äúqui√©n‚Äù es.
- `Inmutables` ‚Üí una vez creados, no se modifican; si cambian, se crea uno nuevo.
- `Comparaci√≥n por valor` ‚Üí dos VOs son iguales si sus atributos son iguales.
- `Encapsula reglas de negocio` ‚Üí puede validar su propio estado (ejm.: un Email VO valida que el formato sea correcto).
- `Principio ‚Äúmake illegal states unrepresentable‚Äù` ‚Üí es imposible crear un VO inv√°lido, porque su constructor lo
  rechaza.

üëâ Ejemplo:

- Una entidad `Customer` tiene identidad (su `id`).
- Su `Email` es un `Value Object`, porque lo que importa es el valor del correo, no un identificador √∫nico.

üëâ En Java, los `Records` son ideales para representar `VOs`, ya que son inmutables por naturaleza y expresivos.

### üÜî `CustomerId(...)`

Representa el `identificador interno` del cliente (`BIGSERIAL` en la BD). Encapsularlo en un VO evita la
`Primitive Obsession` (confundir un `Long` de cliente con un `Long` de cuenta u otro concepto).

````java
public record CustomerId(Long value) {
    public CustomerId {
        if (Objects.isNull(value) || value <= 0) {
            throw new IllegalArgumentException("El ID del cliente debe ser un n√∫mero positivo");
        }
    }
}
````

### üîñ `CustomerCode(...)`

Representa la `referencia externa` del cliente que viaja en la API.
Formato esperado: `CUS-YYYY-XXXXXX` (ejemplo: `CUS-2025-000001`).

````java
public record CustomerCode(String value) {
    public CustomerCode {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El c√≥digo de cliente no puede ser vac√≠o");
        }
        if (!value.matches("^CUS-\\d{4}-\\d{6}$")) {
            throw new IllegalArgumentException("Formato de c√≥digo de cliente inv√°lido. Esperado: CUS-YYYY-XXXXXX");
        }
    }
}
````

### üìÑ `DocumentNumber(...)`

Representa el `n√∫mero de documento de identidad` del cliente. La validaci√≥n cubre:

- `DNI` ‚Üí 8 d√≠gitos.
- `RUC` ‚Üí 11 d√≠gitos.
- `Pasaporte` ‚Üí hasta 20 caracteres alfanum√©ricos.

````java
public record DocumentNumber(String value) {
    public DocumentNumber {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El n√∫mero de documento no puede ser vac√≠o");
        }
        if (value.length() < 8 || value.length() > 20) {
            throw new IllegalArgumentException("El n√∫mero de documento debe tener entre 8 y 20 caracteres");
        }
    }
}
````

### üìß `Email(...)`

Representa el `correo electr√≥nico` del cliente, con validaci√≥n de formato.

````java
public record Email(String value) {

    private static final String EMAIL_REGEX = "^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$";

    public Email {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El email no puede ser vac√≠o");
        }
        if (!value.matches(EMAIL_REGEX)) {
            throw new IllegalArgumentException("El formato de email es inv√°lido: " + value);
        }
    }
}
````

### üìò Conceptos clave sobre Value Objects

- `Expresividad del dominio` ‚Üí un `CustomerId` o `Email` comunican mejor la intenci√≥n que un simple Long o String.
- `Validaciones centralizadas` ‚Üí cada VO asegura que su estado sea v√°lido desde el inicio.
- `Inmutabilidad` ‚Üí evita efectos colaterales y asegura consistencia.
- `Reutilizaci√≥n` ‚Üí pueden usarse en distintas entidades sin duplicar l√≥gica.
- `Primitive Obsession` ‚Üí se evita el uso indiscriminado de tipos primitivos (`String`, `Long`) para conceptos del
  negocio.

## üéØ Customer ‚Äì Excepciones de dominio

Las `excepciones de dominio` representan violaciones a las reglas de negocio.

üìå Principios clave:

- Son `RuntimeException` ‚Üí no obligan a capturarlas en cada llamada.
- Pueden lanzarse tanto desde el `dominio mismo `(cuando una entidad o VO protege sus invariantes) como desde la
  `capa de aplicaci√≥n` (cuando un caso de uso detecta una condici√≥n inv√°lida en la interacci√≥n con el dominio).
- El `GlobalExceptionHandler` en la capa de `infraestructura` se encargar√° de capturarlas y convertirlas en respuestas
  HTTP apropiadas.
- Refuerzan el principio de `ubicar las reglas de negocio en el dominio`, no en la infraestructura.

````java
public class CustomerNotFoundException extends RuntimeException {
    public CustomerNotFoundException(String customerCode) {
        super("No se encontr√≥ el cliente con c√≥digo: %s".formatted(customerCode));
    }
}
````

````java
public class CustomerAlreadyExistsException extends RuntimeException {
    public CustomerAlreadyExistsException(String field, String value) {
        super("Ya existe un cliente registrado con %s: %s".formatted(field, value));
    }
}
````

````java
public class CustomerBlockedException extends RuntimeException {
    public CustomerBlockedException(String customerCode) {
        super("El cliente con c√≥digo %s se encuentra bloqueado y no puede realizar operaciones".formatted(customerCode));
    }
}
````

````java
public class CustomerInactiveException extends RuntimeException {
    public CustomerInactiveException(String customerCode) {
        super("El cliente con c√≥digo %s se encuentra inactivo y no puede realizar operaciones".formatted(customerCode));
    }
}
````

### üìò Conceptos clave sobre excepciones de dominio

- `Expresividad del negocio` ‚Üí cada excepci√≥n comunica claramente la regla violada.


- `Separaci√≥n de responsabilidades` ‚Üí Las excepciones de dominio se `definen en el dominio` como parte del vocabulario
  de reglas de negocio.
    - Pueden lanzarse desde el `Dominio (Entidades, VOs, reglas de negocio)`:
        - Aqu√≠ se lanzan excepciones cuando una regla interna se viola.
        - Ejemplo: en `Customer.validateIsOperational()` se lanza `CustomerBlockedException` o
          `CustomerInactiveException`.
        - üëâ Estas excepciones se disparan porque el propio modelo protege sus invariantes.
    - Pueden lanzarse desde la `Aplicaci√≥n (Casos de uso, servicios de aplicaci√≥n)`:
        - Aqu√≠ se lanzan excepciones cuando el flujo del caso de uso detecta condiciones inv√°lidas externas al modelo.
        - Ejemplo: al buscar un cliente en el repositorio y no encontrarlo ‚Üí `CustomerNotFoundException`.
        - Ejemplo: al intentar registrar un cliente existente ‚Üí `CustomerAlreadyExistsException `.
        - üëâ Estas excepciones se disparan porque el caso de uso no puede continuar.
    - Finalmente, la `Infraestructura (controladores, handlers)` las captura y traduce en respuestas t√©cnicas
      (ej. HTTP 404, 409, 403).


- `Evitan estados inv√°lidos` ‚Üí garantizan que el flujo de negocio no contin√∫e si las condiciones no se cumplen.
- `Consistencia` ‚Üí centralizan las reglas de validaci√≥n y evitan duplicaci√≥n de l√≥gica en distintas capas.
- `Mejor comunicaci√≥n con la API` ‚Üí al capturarlas en el `GlobalExceptionHandler`, se transforman en mensajes claros
  para el cliente de la API.

## üèõÔ∏è Customer ‚Äì Entidad de dominio

La `entidad de dominio` `Customer` es el objeto m√°s importante de esta feature. Encapsula tanto el `estado` como las
`reglas de negocio` del cliente.

üìå Principios clave:

- `Cero dependencias externas` ‚Üí es Java puro, sin anotaciones de JPA, Spring ni frameworks.
    - `Nota`: usamos `Lombok` √∫nicamente para reducir c√≥digo repetitivo (boilerplate). No introduce dependencias de
      frameworks ni afecta la pureza del dominio; al final, el resultado sigue siendo Java puro.
- `El comportamiento vive aqu√≠` ‚Üí los m√©todos de negocio est√°n en la entidad, no en el servicio.
- `La capa de aplicaci√≥n orquesta`, `la entidad ejecuta las reglas`.
- `Factory methods` diferenciados:
    - `create()` ‚Üí para clientes nuevos (sin id, status inicial en `ACTIVE`).
    - `reconstitute()` ‚Üí para reconstruir desde la BD (con id y fechas).
- `Sin setters p√∫blicos` ‚Üí el estado solo cambia mediante m√©todos sem√°nticos (`deactivate()`, `updatePersonalInfo()`),
  evitando el `Anemic Domain Model`.
- `M√©todo reutilizable` ‚Üí `validateIsOperational()` asegura que el cliente pueda operar en cualquier caso de uso.

> üìò ¬øQu√© es el `Anemic Domain Model`?  
> El `Anemic Domain Model` es un anti-patr√≥n en el que las entidades `solo contienen datos`
> (atributos y getters/setters), pero `no encapsulan comportamiento`. En ese escenario:
> - La l√≥gica de negocio se dispersa en servicios externos.
> - Las entidades se convierten en simples ‚Äúbolsas de datos‚Äù.
> - Se pierde expresividad y cohesi√≥n en el dominio.
>
> üëâ En DDD, las entidades deben `contener tanto datos como comportamiento`, asegurando que las reglas de negocio est√©n
> centralizadas y expresadas en el propio modelo.

### üìÑ C√≥digo de la entidad de dominio `Customer`

````java

@Getter
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class Customer {

    // NOTA: Los campos createdAt y updatedAt NO se asignan manualmente en el dominio.
    // La responsabilidad de gestionarlos recae en la capa de infraestructura a trav√©s
    // de las anotaciones @CreationTimestamp y @UpdateTimestamp en CustomerEntity (JPA).
    // De esta forma, la fuente de verdad de las fechas es siempre la base de datos.

    private CustomerId id;
    private CustomerCode customerCode;
    private DocumentNumber documentNumber;
    private DocumentType documentType;
    private String firstName;
    private String lastName;
    private Email email;
    private String phone;
    private CustomerStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // FACTORY METHODS
    // =========================================================

    /**
     * Crea un nuevo cliente que a√∫n NO ha sido persistido.
     * El id es null porque a√∫n no ha sido asignado por la BD.
     * El status se inicializa en ACTIVE porque tod0 cliente nuevo
     * nace activo por regla de negocio.
     */
    public static Customer create(String customerCode,
                                  String documentNumber,
                                  DocumentType documentType,
                                  String firstName,
                                  String lastName,
                                  String email,
                                  String phone) {

        Customer customer = new Customer();
        customer.customerCode = new CustomerCode(customerCode);
        customer.documentNumber = new DocumentNumber(documentNumber);
        customer.documentType = documentType;
        customer.firstName = firstName;
        customer.lastName = lastName;
        customer.email = new Email(email);
        customer.phone = phone;
        customer.status = CustomerStatus.ACTIVE;

        return customer;
    }

    /**
     * Reconstituye un cliente existente desde la base de datos.
     * Usado por el mapper de infraestructura para convertir una
     * CustomerEntity en un Customer de dominio. Aqu√≠ s√≠ se asigna
     * el id porque ya existe en la BD.
     */
    public static Customer reconstitute(Long id,
                                        String customerCode,
                                        String documentNumber,
                                        DocumentType documentType,
                                        String firstName,
                                        String lastName,
                                        String email,
                                        String phone,
                                        CustomerStatus status,
                                        LocalDateTime createdAt,
                                        LocalDateTime updatedAt) {

        Customer customer = new Customer();
        customer.id = new CustomerId(id);
        customer.customerCode = new CustomerCode(customerCode);
        customer.documentNumber = new DocumentNumber(documentNumber);
        customer.documentType = documentType;
        customer.firstName = firstName;
        customer.lastName = lastName;
        customer.email = new Email(email);
        customer.phone = phone;
        customer.status = status;
        customer.createdAt = createdAt;
        customer.updatedAt = updatedAt;

        return customer;
    }

    // COMPORTAMIENTO / REGLAS DE NEGOCIO
    // =========================================================

    /**
     * Verifica que el cliente puede realizar operaciones.
     * Lanza excepci√≥n si est√° bloqueado o inactivo.
     * Reutilizable desde cualquier caso de uso que lo requiera.
     */
    public void validateIsOperational() {
        if (this.status == CustomerStatus.BLOCKED) {
            throw new CustomerBlockedException(this.customerCode.value());
        }
        if (this.status == CustomerStatus.INACTIVE) {
            throw new CustomerInactiveException(this.customerCode.value());
        }
    }

    /**
     * Actualiza los datos personales del cliente.
     * Solo campos no sensibles son modificables.
     * El email y documento no se actualizan por pol√≠tica del banco.
     */
    public void updatePersonalInfo(String firstName, String lastName, String phone) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.phone = phone;
    }

    /**
     * Desactiva el cliente (baja l√≥gica).
     * En un banco jam√°s se eliminan registros f√≠sicamente.
     */
    public void deactivate() {
        this.validateIsOperational();
        this.status = CustomerStatus.INACTIVE;
    }

    /**
     * Retorna el nombre completo del cliente.
     */
    public String getFullName() {
        return String.format("%s %s", this.firstName, this.lastName);
    }
}
````

### üìò Conceptos clave sobre entidades de dominio

- `Identidad propia` ‚Üí a diferencia de los VOs, las entidades se distinguen por su identidad (`CustomerId`).
- `Encapsulan estado y comportamiento` ‚Üí no son simples contenedores de datos.
- `Factory methods` ‚Üí diferencian entre creaci√≥n inicial y reconstrucci√≥n desde la BD.
- `M√©todos sem√°nticos` ‚Üí expresan reglas de negocio de forma clara (`deactivate()`, `updatePersonalInfo()`).
- `Evitan el Anemic Domain Model` ‚Üí la l√≥gica vive en la entidad, no en servicios externos.
- `Infraestructura gestiona metadatos` ‚Üí fechas (`createdAt`, `updatedAt`) se asignan en la capa de persistencia, no en
  el dominio.

# üí≥ Account

## üìë Account ‚Äì Enums

Los `enums` en la capa de dominio representan el `vocabulario del negocio` para las cuentas bancarias.
Son simples, inmutables y expresivos, sin dependencias externas.

````java
public enum AccountStatus {
    ACTIVE,
    INACTIVE,
    BLOCKED,
    CLOSED
}
````

````java
public enum AccountType {
    SAVINGS,   // Cuenta de ahorros
    CHECKING   // Cuenta corriente
}
````

````java
public enum Currency {
    PEN,  // Sol peruano
    USD,  // D√≥lar americano
    EUR   // Euro
}
````

## üí≥ Account ‚Äì Value Objects

Los `Value Objects (VOs)` en la feature `Account` encapsulan conceptos clave del dominio bancario.

üìå Principios:

- `Inmutables` ‚Üí se definen por su valor, no por identidad.
- `Validaciones propias` ‚Üí garantizan que solo existan estados v√°lidos.
- `Evitan Primitive Obsession` ‚Üí no usamos String o Long crudos para representar conceptos del negocio.
- `Expresividad` ‚Üí el c√≥digo refleja mejor la intenci√≥n del negocio.

### üÜî `AccountId(...)`

Representa el `identificador interno` de la cuenta (`BIGSERIAL` en la BD). Encapsularlo en un VO evita confundir
un Long de cuenta con otro concepto del dominio.

````java
public record AccountId(Long value) {

    public AccountId {
        if (Objects.isNull(value) || value <= 0) {
            throw new IllegalArgumentException("El ID de la cuenta debe ser un n√∫mero positivo");
        }
    }
}
````

### üîñ `AccountNumber(...)`

Representa la `referencia externa` de la cuenta que viaja en la API. Formato esperado: `BNK-XXXXXXXXXXXXXX`
(ejemplo: `BNK-20250001234567`).

````java
public record AccountNumber(String value) {

    public AccountNumber {
        if (Objects.isNull(value) || value.isBlank()) {
            throw new IllegalArgumentException("El n√∫mero de cuenta no puede ser vac√≠o");
        }
        if (!value.matches("^BNK-\\d{14}$")) {
            throw new IllegalArgumentException("Formato de n√∫mero de cuenta inv√°lido. Esperado: BNK-XXXXXXXXXXXXXX");
        }
    }
}
````

### üí∞ `Money(...)`

Representa un `valor monetario con su moneda`. Usamos `BigDecimal` para evitar errores de precisi√≥n de punto flotante,
cr√≠ticos en operaciones financieras.

Este VO es el m√°s rico de todos los VOs porque encapsula operaciones financieras completas: `add()`, `subtract()`,
comparaciones, y validaci√≥n de misma moneda antes de operar. Adem√°s, normaliza siempre a 2 decimales con
`RoundingMode.HALF_UP`. Usamos `BigDecimal` porque en finanzas double y float son inaceptables por errores de precisi√≥n
de punto flotante.

````java

public record Money(BigDecimal amount, Currency currency) {

    public Money {
        if (Objects.isNull(amount)) {
            throw new IllegalArgumentException("El monto no puede ser nulo");
        }
        if (Objects.isNull(currency)) {
            throw new IllegalArgumentException("La moneda no puede ser nula");
        }
        // Normalizamos siempre a 2 decimales para consistencia
        amount = amount.setScale(2, RoundingMode.HALF_UP);
    }

    // Factory method para crear Money de forma m√°s legible
    public static Money of(BigDecimal amount, Currency currency) {
        return new Money(amount, currency);
    }

    public static Money zero(Currency currency) {
        return new Money(BigDecimal.ZERO, currency);
    }

    public boolean isGreaterThan(Money other) {
        this.validateSameCurrency(other);
        return this.amount.compareTo(other.amount) > 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        this.validateSameCurrency(other);
        return this.amount.compareTo(other.amount) >= 0;
    }

    public boolean isPositive() {
        return this.amount.compareTo(BigDecimal.ZERO) > 0;
    }

    public boolean isZeroOrNegative() {
        return this.amount.compareTo(BigDecimal.ZERO) <= 0;
    }

    public Money add(Money other) {
        this.validateSameCurrency(other);
        return new Money(this.amount.add(other.amount), this.currency);
    }

    public Money subtract(Money other) {
        this.validateSameCurrency(other);
        return new Money(this.amount.subtract(other.amount), this.currency);
    }

    private void validateSameCurrency(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("No se pueden operar montos de distintas monedas: %s vs %s"
                    .formatted(this.currency, other.currency));
        }
    }
}
````

### üìò Conceptos clave sobre estos VOs

- `AccountId` ‚Üí asegura que el identificador sea v√°lido y positivo.
- `AccountNumber` ‚Üí valida el formato est√°ndar de cuentas bancarias, evitando errores en la API.
- `Money` ‚Üí encapsula operaciones financieras seguras: `suma`, `resta`, `comparaciones`.
- `Validaciones centralizadas` ‚Üí cada VO garantiza su propio estado v√°lido.
- `Consistencia financiera` ‚Üí `BigDecimal` con escala fija evita errores de precisi√≥n.
- `Reutilizaci√≥n` ‚Üí `Money` puede usarse en m√∫ltiples features (ej. `Transaction`, `Balance`).

## üéØ Account ‚Äì Excepciones de dominio

Las `excepciones de dominio` en la feature `Account` representan violaciones a las reglas de negocio relacionadas con
cuentas bancarias.

üìå Principios clave:

- Se `definen en el dominio` como parte del vocabulario de reglas.
- Pueden lanzarse tanto desde el `dominio mismo` (cuando una entidad o VO protege sus invariantes) como desde la
  `capa de aplicaci√≥n` (cuando un caso de uso detecta una condici√≥n inv√°lida en la interacci√≥n con el dominio).
- La `infraestructura` las captura y traduce en respuestas t√©cnicas (ej. HTTP 404, 403, 409).
- Refuerzan la expresividad del modelo y evitan estados inv√°lidos.

````java
public class AccountNotFoundException extends RuntimeException {
    public AccountNotFoundException(String accountNumber) {
        super("No se encontr√≥ la cuenta con n√∫mero: %s".formatted(accountNumber));
    }
}
````

````java
public class AccountBlockedException extends RuntimeException {
    public AccountBlockedException(String accountNumber) {
        super("La cuenta %s se encuentra bloqueada y no puede realizar operaciones".formatted(accountNumber));
    }
}
````

````java
public class AccountClosedException extends RuntimeException {
    public AccountClosedException(String accountNumber) {
        super("La cuenta %s se encuentra cerrada y no puede realizar operaciones".formatted(accountNumber));
    }
}
````

````java
public class AccountInactiveException extends RuntimeException {
    public AccountInactiveException(String accountNumber) {
        super("La cuenta %s se encuentra inactiva y no puede realizar operaciones".formatted(accountNumber));
    }
}
````

````java
public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(BigDecimal balance, BigDecimal amount) {
        super("Salgo insuficiente. Saldo disponible: %.2f, Monto solicitado: %.2f".formatted(balance, amount));
    }
}
````

````java
public class InvalidAmountException extends RuntimeException {
    public InvalidAmountException() {
        super("El monto de la operaci√≥n debe ser mayor a cero");
    }
}
````

````java
public class MaxAccountsReachedException extends RuntimeException {
    public MaxAccountsReachedException(String customerCode, int maxAccounts) {
        super("El cliente %s ya tiene el m√°ximo de %d cuentas activas permitidas".formatted(customerCode, maxAccounts));
    }
}
````

## üí≥ Account ‚Äì Entidad de dominio

### üìå Puntos importantes

- `Lenguaje del negocio` ‚Üí el factory method se llama `open()` en lugar de `create()` porque en el dominio bancario se
  abre una cuenta, no se crea. El lenguaje importa en DDD.
- `Validaci√≥n de operatividad` ‚Üí `validateIsOperational()` usa switch con pattern matching de Java moderno, m√°s limpio
  que if encadenados.
- `Reglas de negocio en el momento de apertura` ‚Üí la validaci√≥n del monto inicial vive en `open()`.
- `Orden de validaciones` ‚Üí en `deposit()` y `withdraw()` primero se valida operatividad, luego el monto. Esto asegura
  que el mensaje de error sea el correcto.
- `Referencias externas` ‚Üí `customerId` es un `Long` simple, no un VO, porque la cuenta solo necesita la referencia al
  `ID interno` del cliente para los joins.
- `Fechas gestionadas por infraestructura` ‚Üí `createdAt` y `updatedAt` se asignan en la capa de persistencia (JPA con
  `@CreationTimestamp` y `@UpdateTimestamp`). La fuente de verdad es la BD.

### üìÑ C√≥digo de la entidad de dominio `Account`

````java

@Getter
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class Account {

    private AccountId id;
    private AccountNumber accountNumber;
    private Long customerId;             // Referencia al cliente por su ID interno
    private AccountType accountType;
    private Money balance;
    private AccountStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // FACTORY METHODS
    // =========================================================

    /**
     * Abre una nueva cuenta bancaria que a√∫n NO ha sido persistida.
     * El id es null porque a√∫n no ha sido asignado por la BD.
     * El balance inicial debe ser mayor a cero por regla de negocio.
     */
    public static Account open(String accountNumber,
                               Long customerId,
                               AccountType accountType,
                               Money initialBalance) {
        if (initialBalance.isZeroOrNegative()) {
            throw new InvalidAmountException();
        }

        Account account = new Account();
        account.accountNumber = new AccountNumber(accountNumber);
        account.customerId = customerId;
        account.accountType = accountType;
        account.balance = initialBalance;
        account.status = AccountStatus.ACTIVE;

        return account;
    }

    /**
     * Reconstituye una cuenta existente desde la base de datos.
     * Usado por el mapper de infraestructura.
     */
    public static Account reconstitute(Long id,
                                       String accountNumber,
                                       Long customerId,
                                       AccountType accountType,
                                       Money balance,
                                       AccountStatus status,
                                       LocalDateTime createdAt,
                                       LocalDateTime updatedAt) {

        Account account = new Account();
        account.id = new AccountId(id);
        account.accountNumber = new AccountNumber(accountNumber);
        account.customerId = customerId;
        account.accountType = accountType;
        account.balance = balance;
        account.status = status;
        account.createdAt = createdAt;
        account.updatedAt = updatedAt;

        return account;
    }

    // COMPORTAMIENTO / REGLAS DE NEGOCIO
    // =========================================================

    /**
     * Verifica que la cuenta puede operar.
     * Lanza excepci√≥n seg√∫n el estado actual de la cuenta.
     */
    public void validateIsOperational() {
        switch (this.status) {
            case BLOCKED -> throw new AccountBlockedException(this.accountNumber.value());
            case CLOSED -> throw new AccountClosedException(this.accountNumber.value());
            case INACTIVE -> throw new AccountInactiveException(this.accountNumber.value());
            default -> { /* ACTIVE: puede operar */ }
        }
    }

    /**
     * Realiza un dep√≥sito en la cuenta.
     * Valida que la cuenta est√© operativa y que el monto sea positivo.
     */
    public void deposit(Money amount) {
        this.validateIsOperational();
        if (amount.isZeroOrNegative()) {
            throw new InvalidAmountException();
        }
        this.balance = this.balance.add(amount);
    }

    /**
     * Realiza un retiro de la cuenta.
     * Valida operatividad, monto positivo y saldo suficiente.
     */
    public void withdraw(Money amount) {
        this.validateIsOperational();
        if (amount.isZeroOrNegative()) {
            throw new InvalidAmountException();
        }
        if (amount.isGreaterThan(this.balance)) {
            throw new InsufficientFundsException(
                    this.balance.amount(),
                    amount.amount()
            );
        }
        this.balance = this.balance.subtract(amount);
    }

    /**
     * Bloquea la cuenta.
     * Una cuenta CLOSED no puede ser bloqueada.
     */
    public void block() {
        if (this.status == AccountStatus.CLOSED) {
            throw new AccountClosedException(this.accountNumber.value());
        }
        this.status = AccountStatus.BLOCKED;
    }

    /**
     * Retorna la moneda de la cuenta.
     * Method de conveniencia para evitar account.getBalance().currency()
     */
    public Currency getCurrency() {
        return this.balance.currency();
    }
}
````

### üìò Conceptos clave sobre entidades de dominio (aplicados a Account)

- `Identidad propia` ‚Üí `AccountId` diferencia una cuenta de otra, incluso si sus atributos coinciden.
- `Factory methods sem√°nticos` ‚Üí `open()` y `reconstitute()` diferencian entre apertura inicial y reconstrucci√≥n desde
  la BD.
- `Reglas de negocio encapsuladas` ‚Üí m√©todos como `deposit()`, `withdraw()`, `block()` aseguran que las operaciones
  respeten las pol√≠ticas bancarias.
- `Validaciones consistentes` ‚Üí `validateIsOperational()` centraliza la l√≥gica de estados inv√°lidos.
- `Evita el Anemic Domain Model` ‚Üí la l√≥gica vive en la entidad, no en servicios externos.
- `Conveniencia sem√°ntica` ‚Üí m√©todos como `getCurrency()` evitan acceder a atributos internos de forma repetitiva.

### üéØ Buenas pr√°cticas reflejadas

- `Lenguaje del negocio` ‚Üí usar t√©rminos como `open`, `withdraw`, `deposit` en lugar de gen√©ricos como `create` o
  `update`.
- `Inmutabilidad parcial` ‚Üí no hay setters p√∫blicos, el estado solo cambia mediante m√©todos de negocio.
- `Consistencia financiera` ‚Üí validaciones de montos (`InvalidAmountException`, `InsufficientFundsException`) protegen
  contra operaciones inv√°lidas.
- `Protecci√≥n de invariantes` ‚Üí la entidad misma lanza excepciones cuando se violan reglas internas.

